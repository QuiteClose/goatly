// Re-implementation of the internal/unless package generated by declare.py
// Each function calling t.Fatalf with an AssertFailed message if the
// condition is not met.
package assert

import (
	"fmt"
	"os"
	"reflect"
	"regexp"
	"strings"
	"testing"
	"time"

	"github.com/quiteclose/goatly/internal/unless"
	"github.com/quiteclose/goatly/pkg/run"
)

///////////////////////////////////////////////////////////////////////////////

// Any will call t.Fatalf unless any item from sub-set b is in a
func Any(t *testing.T, a, b interface{}, message string) bool {
	return unless.Any(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// Contains will call t.Fatalf unless a contains b (sub-set b is in a)
func Contains(t *testing.T, a, b interface{}, message string) bool {
	return unless.Contains(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// DirExists will call t.Fatalf unless the directory exists
func DirExists(t *testing.T, path string, message string) bool {
	return unless.DirExists(path, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// Empty will call t.Fatalf unless the string or slice is empty
func Empty(t *testing.T, a interface{}, message string) bool {
	return unless.Empty(a, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// Equal will call t.Fatalf unless a == b
func Equal(t *testing.T, a, b interface{}, message string) bool {
	return unless.Equal(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// Error will call t.Fatalf unless err is not nil
func Error(t *testing.T, err error, message string) bool {
	return unless.Error(err, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// ErrorContains will call t.Fatalf unless the error message contains the substring
func ErrorContains(t *testing.T, err error, substr string, message string) bool {
	return unless.ErrorContains(err, substr, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// ErrorType will call t.Fatalf unless the error is of the given type
func ErrorType(t *testing.T, err error, errType interface{}, message string) bool {
	return unless.ErrorType(err, errType, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// False will call t.Fatalf unless a == false
func False(t *testing.T, a bool, message string) bool {
	return unless.False(a, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// FileExists will call t.Fatalf unless the file exists
func FileExists(t *testing.T, path string, message string) bool {
	return unless.FileExists(path, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// GreaterThan will call t.Fatalf unless a > b
func GreaterThan(t *testing.T, a, b int, message string) bool {
	return unless.GreaterThan(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// GreaterThanOrEqual will call t.Fatalf unless a >= b
func GreaterThanOrEqual(t *testing.T, a, b int, message string) bool {
	return unless.GreaterThanOrEqual(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// LessThan will call t.Fatalf unless a < b
func LessThan(t *testing.T, a, b int, message string) bool {
	return unless.LessThan(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// LessThanOrEqual will call t.Fatalf unless a <= b
func LessThanOrEqual(t *testing.T, a, b int, message string) bool {
	return unless.LessThanOrEqual(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// LongerThan will call t.Fatalf unless the length of the string or slice is greater than n
func LongerThan(t *testing.T, a interface{}, n int, message string) bool {
	return unless.LongerThan(a, n, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// Matches will call t.Fatalf unless a matches the regex pattern
func Matches(t *testing.T, a, pattern string, message string) bool {
	return unless.Matches(a, pattern, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// Nil will call t.Fatalf unless a == nil
func Nil(t *testing.T, a interface{}, message string) bool {
	return unless.Nil(a, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotAny will call t.Fatalf unless no item from sub-set b is in a
func NotAny(t *testing.T, a, b interface{}, message string) bool {
	return unless.NotAny(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotContains will call t.Fatalf unless a does not contain b (sub-set b is not in a)
func NotContains(t *testing.T, a, b interface{}, message string) bool {
	return unless.NotContains(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotDirExists will call t.Fatalf unless the directory does not exist
func NotDirExists(t *testing.T, path string, message string) bool {
	return unless.NotDirExists(path, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotEmpty will call t.Fatalf unless the string or slice is not empty
func NotEmpty(t *testing.T, a interface{}, message string) bool {
	return unless.NotEmpty(a, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotEqual will call t.Fatalf unless a != b
func NotEqual(t *testing.T, a, b interface{}, message string) bool {
	return unless.NotEqual(a, b, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotError will call t.Fatalf unless err is nil
func NotError(t *testing.T, err error, message string) bool {
	return unless.NotError(err, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotErrorContains will call t.Fatalf unless the error message does not contain the substring
func NotErrorContains(t *testing.T, err error, substr string, message string) bool {
	return unless.NotErrorContains(err, substr, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotErrorType will call t.Fatalf unless the error is not of the given type
func NotErrorType(t *testing.T, err error, errType interface{}, message string) bool {
	return unless.NotErrorType(err, errType, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotFileExists will call t.Fatalf unless the file does not exist
func NotFileExists(t *testing.T, path string, message string) bool {
	return unless.NotFileExists(path, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotMatches will call t.Fatalf unless a does not match the regex pattern
func NotMatches(t *testing.T, a, pattern string, message string) bool {
	return unless.NotMatches(a, pattern, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotNil will call t.Fatalf unless a != nil
func NotNil(t *testing.T, a interface{}, message string) bool {
	return unless.NotNil(a, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotPathExists will call t.Fatalf if the path exists
func NotPathExists(t *testing.T, path string, message string) bool {
	return unless.NotPathExists(path, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotTimeWithin will call t.Fatalf unless the time is not within the duration
func NotTimeWithin(t *testing.T, t1, t2 time.Time, d time.Duration, message string) bool {
	return unless.NotTimeWithin(t1, t2, d, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotType will call t.Fatalf unless a is not of the given type
func NotType(t *testing.T, a interface{}, t reflect.Type, message string) bool {
	return unless.NotType(a, t, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// NotZero will call t.Fatalf unless a is not zero
func NotZero(t *testing.T, a interface{}, message string) bool {
	return unless.NotZero(a, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// PathExists will call t.Fatalf unless the path exists
func PathExists(t *testing.T, path string, message string) bool {
	return unless.PathExists(path, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunError will call t.Fatalf unless the run.Status has an error.
func RunError(t *testing.T, s *run.Status, message string) bool {
	return unless.RunError(s, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunExitCode will call t.Fatalf unless the run.Status has the given exit code.
func RunExitCode(t *testing.T, s *run.Status, exitCode int, message string) bool {
	return unless.RunExitCode(s, exitCode, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunNoError will call t.Fatalf unless the run.Status has an error.
func RunNoError(t *testing.T, s *run.Status, message string) bool {
	return unless.RunNoError(s, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunNonZeroExitCode will call t.Fatalf unless the run.Status has a non-zero exit code.
func RunNonZeroExitCode(t *testing.T, s *run.Status, message string) bool {
	return unless.RunNonZeroExitCode(s, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunStderr will call t.Fatalf unless the run.Status.Stderr contains the given string.
func RunNotStderr(t *testing.T, s *run.Status, expected string, message string) bool {
	return unless.RunNotStderr(s, expected, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunNotStderrMatch will call t.Fatalf if the run.Status.Stderr matches the given regular expression.
func RunNotStderrMatch(t *testing.T, s *run.Status, pattern *regexp.Regexp, message string) bool {
	return unless.RunNotStderrMatch(s, pattern, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunStdout will call t.Fatalf unless the run.Status.Stdout contains the given string.
func RunNotStdout(t *testing.T, s *run.Status, expected string, message string) bool {
	return unless.RunNotStdout(s, expected, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunNotStdoutMatch will call t.Fatalf if the run.Status.Stdout matches the given regular expression.
func RunNotStdoutMatch(t *testing.T, s *run.Status, pattern *regexp.Regexp, message string) bool {
	return unless.RunNotStdoutMatch(s, pattern, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunStderr will call t.Fatalf unless the run.Status.Stderr contains the given string.
func RunStderr(t *testing.T, s *run.Status, expected string, message string) bool {
	return unless.RunStderr(s, expected, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunStderrMatch will call t.Fatalf unless the run.Status.Stderr matches the given regular expression.
func RunStderrMatch(t *testing.T, s *run.Status, pattern *regexp.Regexp, message string) bool {
	return unless.RunStderrMatch(s, pattern, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunStdout will call t.Fatalf unless the run.Status.Stdout contains the given string.
func RunStdout(t *testing.T, s *run.Status, expected string, message string) bool {
	return unless.RunStdout(s, expected, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// RunStdoutMatch will call t.Fatalf unless the run.Status.Stdout matches the given regular expression.
func RunStdoutMatch(t *testing.T, s *run.Status, pattern *regexp.Regexp, message string) bool {
	return unless.RunStdoutMatch(s, pattern, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// ShorterThan will call t.Fatalf unless the length of the string or slice is less than n
func ShorterThan(t *testing.T, a interface{}, n int, message string) bool {
	return unless.ShorterThan(a, n, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// TimeAfter will call t.Fatalf unless t1 is after t2
func TimeAfter(t *testing.T, t1, t2 time.Time, message string) bool {
	return unless.TimeAfter(t1, t2, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// TimeBefore will call t.Fatalf unless t1 is before t2
func TimeBefore(t *testing.T, t1, t2 time.Time, message string) bool {
	return unless.TimeBefore(t1, t2, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// TimeWithin will call t.Fatalf unless the time is within the duration
func TimeWithin(t *testing.T, t1, t2 time.Time, d time.Duration, message string) bool {
	return unless.TimeWithin(t1, t2, d, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// True will call t.Fatalf unless a == true
func True(t *testing.T, a bool, message string) bool {
	return unless.True(a, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// Type will call t.Fatalf unless a is of the given type
func Type(t *testing.T, a interface{}, t reflect.Type, message string) bool {
	return unless.Type(a, t, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}

// Zero will call t.Fatalf unless a is zero
func Zero(t *testing.T, a interface{}, message string) bool {
	return unless.Zero(a, func(s string) {
		t.Fatalf("AssertFailed: %s\n%s", message, s)
	})
}
