// Re-implementation of the internal/unless package generated by declare.py
// Each function calling t.Errorf with an ExpectFailed message if the
// condition is not met.
package expect

import (
	"reflect"
	"regexp"
	"strings"
	"testing"
	"time"

	"github.com/quiteclose/goatly/internal/unless"
	"github.com/quiteclose/goatly/pkg/run"
)

///////////////////////////////////////////////////////////////////////////////

// Any call t.Errorf unless any item from sub-set b is in a
func Any(t *testing.T, a, b interface{}) , message string) bool {
    conditionMet, reason := is.Any
	return unless.Any(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// Contains call t.Errorf unless a contains b (sub-set b is in a)
func Contains(t *testing.T, a, b interface{}) , message string) bool {
    conditionMet, reason := is.Contains
	return unless.Contains(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// DirExists call t.Errorf unless the directory exists
func DirExists(t *testing.T, path string) , message string) bool {
    conditionMet, reason := is.DirExists
	return unless.DirExists(path, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// Empty call t.Errorf unless the string or slice is empty
func Empty(t *testing.T, a interface{}) , message string) bool {
    conditionMet, reason := is.Empty
	return unless.Empty(a, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// Equal call t.Errorf unless a == b
func Equal(t *testing.T, a, b interface{}) , message string) bool {
    conditionMet, reason := is.Equal
	return unless.Equal(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// Error call t.Errorf unless err is not nil
func Error(t *testing.T, err error) , message string) bool {
    conditionMet, reason := is.Error
	return unless.Error(err, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// ErrorContains call t.Errorf unless the error message contains the substring
func ErrorContains(t *testing.T, err error, substr string) , message string) bool {
    conditionMet, reason := is.ErrorContains
	return unless.ErrorContains(err, substr, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// ErrorType call t.Errorf unless the error is of the given type
func ErrorType(t *testing.T, err error, errType interface{}) , message string) bool {
    conditionMet, reason := is.ErrorType
	return unless.ErrorType(err, errType, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// False call t.Errorf unless a == false
func False(t *testing.T, a bool) , message string) bool {
    conditionMet, reason := is.False
	return unless.False(a, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// FileExists call t.Errorf unless the file exists
func FileExists(t *testing.T, path string) , message string) bool {
    conditionMet, reason := is.FileExists
	return unless.FileExists(path, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// GreaterThan call t.Errorf unless a > b
func GreaterThan(t *testing.T, a, b int) , message string) bool {
    conditionMet, reason := is.GreaterThan
	return unless.GreaterThan(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// GreaterThanOrEqual call t.Errorf unless a >= b
func GreaterThanOrEqual(t *testing.T, a, b int) , message string) bool {
    conditionMet, reason := is.GreaterThanOrEqual
	return unless.GreaterThanOrEqual(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// LessThan call t.Errorf unless a < b
func LessThan(t *testing.T, a, b int) , message string) bool {
    conditionMet, reason := is.LessThan
	return unless.LessThan(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// LessThanOrEqual call t.Errorf unless a <= b
func LessThanOrEqual(t *testing.T, a, b int) , message string) bool {
    conditionMet, reason := is.LessThanOrEqual
	return unless.LessThanOrEqual(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// LongerThan call t.Errorf unless the length of the string or slice is greater than n
func LongerThan(t *testing.T, a interface{}, n int) , message string) bool {
    conditionMet, reason := is.LongerThan
	return unless.LongerThan(a, n, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// Matches call t.Errorf unless a matches the regex pattern
func Matches(t *testing.T, a, pattern string) , message string) bool {
    conditionMet, reason := is.Matches
	return unless.Matches(a, pattern, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// Nil call t.Errorf unless a == nil
func Nil(t *testing.T, a interface{}) , message string) bool {
    conditionMet, reason := is.Nil
	return unless.Nil(a, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotAny call t.Errorf unless no item from sub-set b is in a
func NotAny(t *testing.T, a, b interface{}) , message string) bool {
    conditionMet, reason := is.NotAny
	return unless.NotAny(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotContains call t.Errorf unless a does not contain b (sub-set b is not in a)
func NotContains(t *testing.T, a, b interface{}) , message string) bool {
    conditionMet, reason := is.NotContains
	return unless.NotContains(a, b, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotDirExists call t.Errorf unless the directory does not exist
func NotDirExists(t *testing.T, path string) , message string) bool {
    conditionMet, reason := is.NotDirExists
	return unless.NotDirExists(path, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotEmpty call t.Errorf unless the string or slice is not empty
func NotEmpty(t *testing.T, a interface{}) , message string) bool {
    conditionMet, reason := is.NotEmpty
	return unless.NotEmpty(a, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotError call t.Errorf unless err is nil
func NotError(t *testing.T, err error) , message string) bool {
    conditionMet, reason := is.NotError
	return unless.NotError(err, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotErrorContains call t.Errorf unless the error message does not contain the substring
func NotErrorContains(t *testing.T, err error, substr string) , message string) bool {
    conditionMet, reason := is.NotErrorContains
	return unless.NotErrorContains(err, substr, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotErrorType call t.Errorf unless the error is not of the given type
func NotErrorType(t *testing.T, err error, errType interface{}) , message string) bool {
    conditionMet, reason := is.NotErrorType
	return unless.NotErrorType(err, errType, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotFileExists call t.Errorf unless the file does not exist
func NotFileExists(t *testing.T, path string) , message string) bool {
    conditionMet, reason := is.NotFileExists
	return unless.NotFileExists(path, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotMatches call t.Errorf unless a does not match the regex pattern
func NotMatches(t *testing.T, a, pattern string) , message string) bool {
    conditionMet, reason := is.NotMatches
	return unless.NotMatches(a, pattern, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotPathExists call t.Errorf unless the path does not exist
func NotPathExists(t *testing.T, path string) , message string) bool {
    conditionMet, reason := is.NotPathExists
	return unless.NotPathExists(path, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotTimeWithin call t.Errorf unless the time is not within the duration
func NotTimeWithin(t *testing.T, t1, t2 time.Time, d time.Duration) , message string) bool {
    conditionMet, reason := is.NotTimeWithin
	return unless.NotTimeWithin(t1, t2, d, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotType call t.Errorf unless a is not of the given type
func NotType(t *testing.T, a interface{}, t reflect.Type) , message string) bool {
    conditionMet, reason := is.NotType
	return unless.NotType(a, t, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// NotZero call t.Errorf unless a is not zero
func NotZero(t *testing.T, a interface{}) , message string) bool {
    conditionMet, reason := is.NotZero
	return unless.NotZero(a, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// PathExists call t.Errorf unless the path exists
func PathExists(t *testing.T, path string) , message string) bool {
    conditionMet, reason := is.PathExists
	return unless.PathExists(path, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// ShorterThan call t.Errorf unless the length of the string or slice is less than n
func ShorterThan(t *testing.T, a interface{}, n int) , message string) bool {
    conditionMet, reason := is.ShorterThan
	return unless.ShorterThan(a, n, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// TimeAfter call t.Errorf unless t1 is after t2
func TimeAfter(t *testing.T, t1, t2 time.Time) , message string) bool {
    conditionMet, reason := is.TimeAfter
	return unless.TimeAfter(t1, t2, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// TimeBefore call t.Errorf unless t1 is before t2
func TimeBefore(t *testing.T, t1, t2 time.Time) , message string) bool {
    conditionMet, reason := is.TimeBefore
	return unless.TimeBefore(t1, t2, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// TimeWithin call t.Errorf unless the time is within the duration
func TimeWithin(t *testing.T, t1, t2 time.Time, d time.Duration) , message string) bool {
    conditionMet, reason := is.TimeWithin
	return unless.TimeWithin(t1, t2, d, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// True call t.Errorf unless a == true
func True(t *testing.T, a bool) , message string) bool {
    conditionMet, reason := is.True
	return unless.True(a, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// Type call t.Errorf unless a is of the given type
func Type(t *testing.T, a interface{}, t reflect.Type) , message string) bool {
    conditionMet, reason := is.Type
	return unless.Type(a, t, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}

// Zero call t.Errorf unless a is zero
func Zero(t *testing.T, a interface{}) , message string) bool {
    conditionMet, reason := is.Zero
	return unless.Zero(a, func(s string) {
		t.Errorf("ExpectFailed: %s\n%s", message, s)
	})
}
